<h1 id="theory">Theory<a aria-hidden="true" class="anchor-heading icon-link" href="#theory"></a></h1>
<h2 id="제어-역전">제어 역전<a aria-hidden="true" class="anchor-heading icon-link" href="#제어-역전"></a></h2>
<h3 id="what">What<a aria-hidden="true" class="anchor-heading icon-link" href="#what"></a></h3>
<ul>
<li><strong>IoC</strong>(Inversion of Control)</li>
<li>프로그래머가 작성한 프로그램이 재사용 라이브러리의 흐름 제어를 받게 되는 소프트웨어 디자인 패턴</li>
<li>전통적인 프로그래밍에서 흐름은 프로그래머가 작성한 프로그램이 외부 라이브러리의 코드를 호출해 이용</li>
<li>제어 역전이 적용된 구조에서는 외부 라이브러리의 코드가 프로그래머가 작성한 코드를 호출</li>
</ul>
<h3 id="why">Why<a aria-hidden="true" class="anchor-heading icon-link" href="#why"></a></h3>
<ul>
<li>작업을 구현하는 방식과 작업 수행 자체를 분리</li>
<li>모듈을 제작할 때, 모듈과 외부 프로그램의 결합에 대해 고민할 필요 없이 모듈의 목적에 집중할 수 있음</li>
</ul>
<h3 id="references">References<a aria-hidden="true" class="anchor-heading icon-link" href="#references"></a></h3>
<ul>
<li><a href="https://ko.m.wikipedia.org/wiki/%EC%A0%9C%EC%96%B4_%EB%B0%98%EC%A0%84">https://ko.m.wikipedia.org/wiki/%EC%A0%9C%EC%96%B4_%EB%B0%98%EC%A0%84</a></li>
</ul>
<h2 id="의존관계-역전-원칙">의존관계 역전 원칙<a aria-hidden="true" class="anchor-heading icon-link" href="#의존관계-역전-원칙"></a></h2>
<h3 id="what-1">What<a aria-hidden="true" class="anchor-heading icon-link" href="#what-1"></a></h3>
<ul>
<li>객체 지향 프로그래밍에서 소프트웨어 모듈들을 분리하는 특정 형식을 지칭</li>
<li>이 원칙을 따르면, 상위 계층(정책 결정)이 하위 계층(세부 사항)에 의존하는 전통적인 의존 관계를 반전(역전)시킴으로써 상위 계층이 하위 계층의 구현으로부터 독립되게 할 수 있음</li>
<li>이 원칙은 '상위와 하위 객체 모두가 동일한 추상화에 의존해야 한다'는 객체 지향적 설계의 대원칙을 제공
<ul>
<li>첫째, 상위 모듈은 하위 모듈에 의존해서는 안된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.</li>
<li>둘째, 추상화는 세부 사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다.</li>
</ul>
</li>
</ul>
<h3 id="references-1">References<a aria-hidden="true" class="anchor-heading icon-link" href="#references-1"></a></h3>
<ul>
<li><a href="https://ko.m.wikipedia.org/wiki/%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84_%EC%97%AD%EC%A0%84_%EC%9B%90%EC%B9%99">https://ko.m.wikipedia.org/wiki/%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84_%EC%97%AD%EC%A0%84_%EC%9B%90%EC%B9%99</a></li>
</ul>